import pytest
from fastapi.testclient import TestClient
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool
from main import app
from db.session import get_db
from models import Base
import os
from unittest.mock import AsyncMock, patch

# Test database URL
TEST_DATABASE_URL = "sqlite+aiosqlite:///:memory:"

@pytest.fixture
def test_db():
    """Create a test database session."""
    engine = create_async_engine(
        TEST_DATABASE_URL,
        connect_args={"check_same_thread": False},
        poolclass=StaticPool,
    )
    
    async_session = sessionmaker(
        engine, class_=AsyncSession, expire_on_commit=False
    )
    
    async def override_get_db():
        async with async_session() as session:
            yield session
    
    app.dependency_overrides[get_db] = override_get_db
    
    async def init_test_db():
        async with engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)
    
    return engine, async_session, init_test_db

@pytest.fixture
def client():
    """Create a test client."""
    return TestClient(app)

@pytest.fixture
def mock_llama_api():
    """Mock the Llama API responses."""
    with patch("httpx.AsyncClient") as mock_client:
        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "response": "This is a test summary generated by the mock Llama API."
        }
        mock_client.return_value.__aenter__.return_value.post.return_value = mock_response
        yield mock_client

@pytest.fixture
def mock_book_service():
    """Mock the book service responses."""
    with patch("httpx.AsyncClient") as mock_client:
        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "id": 1,
            "title": "Test Book",
            "author": "Test Author"
        }
        mock_client.return_value.__aenter__.return_value.get.return_value = mock_response
        yield mock_client

@pytest.fixture
def mock_auth():
    """Mock authentication."""
    with patch("utils.auth.verify_auth") as mock:
        mock.return_value = 1  # Return user_id 1
        yield mock

@pytest.fixture
def test_credentials():
    """Test credentials for basic auth."""
    return ("test_user", "test_password") 